<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 2 — Collections & Documents</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body style="--accent:#2980b9; --th:#2980b9;">
<div class="container">
    <h1>Unit 2 — Collections & Documents</h1>

    <nav>
        <a class="btn-home" href="index.html">Home</a>
        <a class="btn-u1" href="unit1.html">Unit 1</a>
        <a class="btn-u2" href="unit2.html">Unit 2</a>
        <a class="btn-u3" href="unit3.html">Unit 3</a>
    </nav>

    <h2>Introduction to Collection</h2>
    <p>A <strong>collection</strong> is a grouping of MongoDB documents. Collections live inside a database and are the equivalent of tables in relational databases, but they are schema-flexible (documents in a collection don't have to share the same fields or structure).</p>

    <h3>Collection vs Table</h3>
    <p>Key differences and trade-offs:</p>
    <table>
        <tr><th>Feature</th><th>Collection</th><th>SQL Table</th></tr>
        <tr><td>Schema</td><td>Dynamic — documents can vary</td><td>Fixed — enforced by schema</td></tr>
        <tr><td>Structure</td><td>Documents (BSON)</td><td>Rows (columns)</td></tr>
        <tr><td>Joins</td><td>Use <code>$lookup</code> or embed documents</td><td>JOINs across tables</td></tr>
        <tr><td>Scaling</td><td>Designed for horizontal sharding</td><td>Often vertical scaling</td></tr>
    </table>

    <h2>Create Collection</h2>
    <p>Collections are created implicitly when you first insert a document into them. You can also create them explicitly with <code>db.createCollection()</code> when you need special options (capped collections, size limits, validation rules).</p>
    <pre>// Implicit creation (first write creates collection)
db.products.insertOne({ name: "Laptop", price: 999 })

// Explicit creation with options
 db.createCollection("logs", { capped: true, size: 1048576 })</pre>

    <h2>Drop Collection</h2>
    <p>To remove an entire collection and its data, use <code>db.collection.drop()</code>. This operation is irreversible — ensure you have backups if needed.</p>
    <pre>// Drop the products collection
db.products.drop()</pre>

    <h2>Introduction to Documents</h2>
    <p>A <strong>document</strong> is the basic unit of data in MongoDB — a BSON (Binary JSON) object. Documents are similar to JSON objects but support additional data types and are stored in a binary format for efficiency.</p>

    <h3>Document Structure</h3>
    <div class="example">
        <p>Documents are composed of field-value pairs:</p>
        <pre>{
  field1: value1,
  field2: value2,
  field3: value3,
  // ... more fields
}</pre>
        <ul>
            <li>Each document requires a unique <code>_id</code> field (primary key).</li>
            <li>If you don't provide <code>_id</code>, MongoDB adds an <code>ObjectId</code> automatically.</li>
            <li>Documents in the same collection can have different fields (schema flexibility).</li>
            <li><strong>Max document size:</strong> 16 MB per document.</li>
        </ul>
    </div>

    <h3>BSON Data Types — Insert examples (mongo shell)</h3>

    <p>Below are copy-pasteable <code>mongosh</code> / mongo shell insert examples demonstrating one document per BSON type using the <code>examples</code> collection. Run them against a test database (for example: <code>use test</code>), then inspect with <code>db.examples.find().pretty()</code>.</p>

    <h4>String</h4>
    <pre>// String
db.examples.insertOne({ _type: "String", value: "Hello, MongoDB!" })</pre>

    <h4>Int32 and Int64</h4>
    <pre>// Int32 (NumberInt helper may be available in some shells/drivers)
db.examples.insertOne({ _type: "Int32", value: NumberInt ? NumberInt(42) : 42 })

// Int64 (NumberLong)
db.examples.insertOne({ _type: "Int64", value: NumberLong("9007199254740992") })</pre>

    <h4>Double</h4>
    <pre>// Double (JS Numbers are doubles in many drivers)
db.examples.insertOne({ _type: "Double", value: 3.14159 })</pre>

    <h4>Decimal128</h4>
    <pre>// Decimal128 (exact decimal representation)
db.examples.insertOne({ _type: "Decimal128", value: NumberDecimal("12345.6789") })</pre>

    <h4>Boolean</h4>
    <pre>// Boolean
db.examples.insertOne({ _type: "Boolean", value: true })</pre>

    <h4>Date</h4>
    <pre>// Date (milliseconds since epoch stored internally)
db.examples.insertOne({ _type: "Date", value: new Date("2025-11-01T00:00:00Z") })</pre>

    <h4>Timestamp (internal use)</h4>
    <pre>// Timestamp — typically used internally (oplog); included here for completeness
db.examples.insertOne({ _type: "Timestamp", value: Timestamp(1620000000, 1) })</pre>

    <h4>ObjectId</h4>
    <pre>// ObjectId (12-byte identifier)
db.examples.insertOne({ _type: "ObjectId", _id: ObjectId(), note: "auto-generated _id as ObjectId" })</pre>

    <h4>Binary (BinData)</h4>
    <pre>// Binary data (base64 payload shown)
db.examples.insertOne({ _type: "Binary", value: BinData(0, "SGVsbG8gYmFzZTY0") })</pre>

    <h4>Array</h4>
    <pre>// Array stored as ordered list
db.examples.insertOne({ _type: "Array", tags: ["mongodb", "nosql", "bson"] })</pre>

    <h4>Embedded Document</h4>
    <pre>// Embedded (nested) document
db.examples.insertOne({ _type: "Embedded", profile: { firstName: "Alice", lastName: "Smith", age: NumberInt ? NumberInt(28) : 28 } })</pre>

    <h4>Null</h4>
    <pre>// Null value
db.examples.insertOne({ _type: "Null", value: null })</pre>

    <h4>Regular Expression</h4>
    <pre>// Regular expression
db.examples.insertOne({ _type: "Regex", pattern: /mongo.*db/i })</pre>

    <h4>JavaScript / Code</h4>
    <pre>// JavaScript code (store as Code object if supported)
db.examples.insertOne({ _type: "Code", code: Code ? Code("function(x){return x>0}") : "function(x){return x>0}" })</pre>

    <h4>MinKey / MaxKey</h4>
    <pre>// MinKey / MaxKey (used for range/index boundaries)
db.examples.insertOne({ _type: "MinKey", value: MinKey() })
db.examples.insertOne({ _type: "MaxKey", value: MaxKey() })</pre>

    <hr>
    <p><strong>Notes</strong></p>
    <ul>
        <li>Some helper constructors (NumberInt, NumberLong, NumberDecimal, BinData, Code, MinKey, MaxKey, Timestamp) are available in the mongo shell / mongosh. Drivers expose similar helpers (e.g., in Node.js use <code>Long</code>, <code>Decimal128</code>, <code>Binary</code>).</li>
        <li>When using language drivers (Node.js, Python, Java), use the driver's BSON helper types to preserve precision for 64-bit integers and Decimal128 values.</li>
        <li>These examples insert into the <code>examples</code> collection so you can inspect a variety of types in one place. Remove or change the collection name as needed for your project.</li>
    </ul>

    <h3>Field Name Rules</h3>
    <div class="note">
        <ul>
            <li>Field names are case-sensitive</li>
            <li>Cannot contain <code>\0</code> (null character)</li>
            <li>Cannot start with <code>$</code> (reserved for operators)</li>
            <li>Cannot contain <code>.</code> (dot) (used for accessing nested fields)</li>
            <li><code>_id</code> is reserved for the primary key</li>
        </ul>
    </div>

    <h3>Document Example</h3>
    <pre>{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  username: "john_doe",
  profile: {
    firstName: "John",
    lastName: "Doe",
    age: 30,
    email: "john@example.com"
  },
  tags: ["developer", "mongodb", "javascript"],
  lastLogin: new Date("2025-10-31"),
  isActive: true,
  loginCount: NumberInt(42),
  metadata: null
}</pre>

    <div class="tip">
        <strong>Best Practices:</strong>
        <ul>
            <li>Use descriptive field names that reflect the data's purpose.</li>
            <li>Consider document growth when designing your schema.</li>
            <li>Use arrays for one-to-few relationships (embedded documents).</li>
            <li>Keep document size under 16MB to avoid splitting.</li>
        </ul>
    </div>

    <h2>Operations on Collections (CRUD and more)</h2>
    <p>Common operations you will use with collections.</p>

    <h4>Insert Documents</h4>
    <pre>// Insert one document
db.inventory.insertOne({ item: "pen", qty: 100 })

// Insert many documents
db.inventory.insertMany([
  { item: "notebook", qty: 200 },
  { item: "eraser", qty: 500 }
])</pre>

    <h4>Query / Find</h4>
    <pre>// Find all documents
 db.inventory.find()

// Find with filter and projection
 db.inventory.find({ qty: { $gt: 50 } }, { item: 1, qty: 1, _id: 0 }).pretty()

// Count results
 db.inventory.countDocuments({ qty: { $gt: 50 } })</pre>

    <h4>Update Documents</h4>
    <p>Use update operators to modify fields rather than replacing whole documents (unless you intend to replace).</p>
    <pre>// Update one document using $set
 db.inventory.updateOne({ item: "pen" }, { $set: { status: "active" } })

// Update many documents using $inc
 db.inventory.updateMany({ qty: { $lt: 30 } }, { $inc: { qty: 10 } })

// Replace a document entirely
 db.inventory.replaceOne({ _id: ObjectId("...") }, { item: "pen", qty: 120 })

// Upsert (update or insert)
 db.inventory.updateOne({ item: "marker" }, { $set: { qty: 50 } }, { upsert: true })</pre>

    <h4>Delete Documents</h4>
    <pre>// Delete one
db.inventory.deleteOne({ status: "inactive" })

// Delete many
db.inventory.deleteMany({ qty: 0 })</pre>

    <h4>Bulk Operations</h4>
    <p>For high-performance writes, use <code>bulkWrite()</code> to group operations:</p>
    <pre>db.collection.bulkWrite([
  { insertOne: { document: { a: 1 } } },
  { updateOne: { filter: { a: 1 }, update: { $set: { b: 1 } } } },
  { deleteOne: { filter: { a: 2 } } }
])</pre>
    <div class="footer">Return to <a href="index.html">Home</a> — or open Unit 1 / Unit 3 above.</div>
</div>
</body>
</html>
