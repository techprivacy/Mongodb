<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 2 — Collections & Documents</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body style="--accent:#2980b9; --th:#2980b9;">
<div class="container">
    <h1>Unit 2 — Collections & Documents</h1>

    <nav>
        <a class="btn-home" href="index.html">Home</a>
        <a class="btn-u1" href="unit1.html">Unit 1</a>
        <a class="btn-u2" href="unit2.html">Unit 2</a>
        <a class="btn-u3" href="unit3.html">Unit 3</a>
    </nav>

    <h2>Introduction to Collection</h2>
    <p>A <strong>collection</strong> is a grouping of MongoDB documents. Collections live inside a database and are the equivalent of tables in relational databases, but they are schema-flexible (documents in a collection don't have to share the same fields or structure).</p>

    <h3>Collection vs Table</h3>
    <p>Key differences and trade-offs:</p>
    <table>
        <tr><th>Feature</th><th>Collection</th><th>SQL Table</th></tr>
        <tr><td>Schema</td><td>Dynamic — documents can vary</td><td>Fixed — enforced by schema</td></tr>
        <tr><td>Structure</td><td>Documents (BSON)</td><td>Rows (columns)</td></tr>
        <tr><td>Joins</td><td>Use <code>$lookup</code> or embed documents</td><td>JOINs across tables</td></tr>
        <tr><td>Scaling</td><td>Designed for horizontal sharding</td><td>Often vertical scaling</td></tr>
    </table>

    <h2>Create Collection</h2>
    <p>Collections are created implicitly when you first insert a document into them. You can also create them explicitly with <code>db.createCollection()</code> when you need special options (capped collections, size limits, validation rules).</p>
    <pre>// Implicit creation (first write creates collection)
db.products.insertOne({ name: "Laptop", price: 999 })

// Explicit creation with options
 db.createCollection("logs", { capped: true, size: 1048576 })</pre>

    <h2>Drop Collection</h2>
    <p>To remove an entire collection and its data, use <code>db.collection.drop()</code>. This operation is irreversible — ensure you have backups if needed.</p>
    <pre>// Drop the products collection
db.products.drop()</pre>

    <h2>Introduction to Documents</h2>
    <p>A <strong>document</strong> is the basic unit of data in MongoDB — a BSON (Binary JSON) object. Documents are similar to JSON objects but support additional data types and are stored in a binary format for efficiency.</p>

    <h3>Document Structure</h3>
    <div class="example">
        <p>Documents are composed of field-value pairs:</p>
        <pre>{
  field1: value1,
  field2: value2,
  field3: value3,
  // ... more fields
}</pre>
        <ul>
            <li>Each document requires a unique <code>_id</code> field (primary key).</li>
            <li>If you don't provide <code>_id</code>, MongoDB adds an <code>ObjectId</code> automatically.</li>
            <li>Documents in the same collection can have different fields (schema flexibility).</li>
            <li><strong>Max document size:</strong> 16 MB per document.</li>
        </ul>
    </div>

    <h3>BSON Data Types (detailed)</h3>

    <p>The BSON (Binary JSON) type system is richer than plain JSON. Below are the common BSON types with what they mean, how they are stored internally, typical sizes/limits, examples and driver notes.</p>

    <h4>String</h4>
    <p>UTF-8 encoded text. Stored as: <code>int32 length + utf8 bytes + \x00</code>. Size depends on string length (1 byte per ASCII char, more for multi-byte UTF-8).</p>
    <pre>// Shell example
db.users.insertOne({ name: "Alice", bio: "Loves databases" })</pre>
    <p><strong>Notes:</strong> Good for searchable text; consider text indexes for full-text search. MongoDB stores the length prefix so very long strings increase document size.</p>

    <h4>Integer (Int32 / Int64 / NumberLong)</h4>
    <p>Numeric integer types: Int32 (4 bytes) and Int64/NumberLong (8 bytes). Internally stored as fixed-size binary integers.</p>
    <pre>// Int32 (by default in many drivers)
{ count: 42 }  // Int32 uses 4 bytes
// Int64 explicitly
{ bigCount: NumberLong("9007199254740992") }  // 8 bytes</pre>
    <p><strong>Notes:</strong> Use Int64 when values can exceed 32-bit range. JavaScript Number is a double; many drivers provide helper types (NumberLong) to preserve 64-bit integers.</p>

    <h4>Double (64-bit floating point)</h4>
    <p>IEEE 754 64-bit floating point (8 bytes). Used for fractional numbers and most numeric computations in JavaScript environments.</p>
    <pre>{ price: 19.95 }  // stored as Double (8 bytes)</pre>
    <p><strong>Notes:</strong> Beware floating-point rounding; for financial values consider <code>Decimal128</code>.</p>

    <h4>Decimal128</h4>
    <p>128-bit decimal-based floating point (IEEE 754-2008 Decimal128). Stored as 16 bytes and preserves decimal precision for money and high-precision calculations.</p>
    <pre>// Shell example
db.orders.insertOne({ amount: NumberDecimal("12345.67") })</pre>
    <p><strong>Notes:</strong> Preferred for financial data. Not all query operators behave identically for Decimal128 vs Double; be consistent in your schema.</p>

    <h4>Boolean</h4>
    <p>Single byte (<code>0x00</code> for false, <code>0x01</code> for true).</p>
    <pre>{ isActive: true }</pre>

    <h4>Date</h4>
    <p>Stored as a 64-bit signed integer representing milliseconds since the Unix epoch (UTC). Internal storage size: 8 bytes.</p>
    <pre>{ createdAt: new Date() }</pre>
    <p><strong>Notes:</strong> Returned to drivers as native date/time objects (e.g., JS Date). For high-resolution or ordering across clusters, also consider <code>Timestamp</code>.</p>

    <h4>Timestamp</h4>
    <p>Special internal BSON type used for replication and internal MongoDB purposes; composed of an unsigned 32-bit increment and an unsigned 32-bit seconds value (8 bytes total).</p>
    <pre>// Typical use is internal, but visible in documents created by some drivers/tools
{ ts: Timestamp(1620000000, 1) }</pre>
    <p><strong>Notes:</strong> Don't use Timestamp for general-purpose dates; prefer <code>Date</code>. Timestamps are primarily for internal replication oplog use.</p>

    <h4>ObjectId</h4>
    <p>12-byte BSON type used as the default <code>_id</code>. Structure: 4-byte timestamp (seconds), 5-byte random value (or machine+pid), 3-byte increment. Total: 12 bytes.</p>
    <pre>{ _id: ObjectId("507f1f77bcf86cd799439011") }</pre>
    <p><strong>Notes:</strong> Encodes creation time and provides good uniqueness without coordination. Can be used for sorting by creation time; avoid relying on ObjectId for business semantics.</p>

    <h4>Binary (BinData)</h4>
    <p>Arbitrary byte arrays. Stored as: length + subtype + raw bytes. Useful for images, encrypted blobs, or driver-specific binary types.</p>
    <pre>{ avatar: BinData(0, "...base64...") }</pre>
    <p><strong>Notes:</strong> For large files prefer GridFS. Choose appropriate subtype when driver interoperability matters.</p>

    <h4>Array</h4>
    <p>Ordered list of values. Internally stored as a document with integer string keys ("0", "1", ...). Size varies with contents.</p>
    <pre>{ tags: ["mongodb", "nosql", "db"] }</pre>
    <p><strong>Notes:</strong> Arrays are powerful but can complicate indexing and updates; use <code>$elemMatch</code> and array-specific operators.</p>

    <h4>Embedded Document (Object)</h4>
    <p>Documents may contain other documents (nested objects). Stored as a nested BSON document.</p>
    <pre>{ profile: { firstName: "Alice", age: 28 } }</pre>
    <p><strong>Notes:</strong> Embed for one-to-few relationships; reference for one-to-many or when sub-documents grow unbounded.</p>

    <h4>Null</h4>
    <p>Represents a null value (no value). Stored as a specific BSON null type (1 byte).</p>
    <pre>{ metadata: null }</pre>

    <h4>Regular Expression</h4>
    <p>BSON stores regexes as a pattern string and options string. Useful for pattern matching queries.</p>
    <pre>{ slug: /mongo.*db/i }</pre>

    <h4>JavaScript / Code</h4>
    <p>BSON supports embedding JavaScript code with optional scope (an object). Mostly historical; use carefully due to security and driver support differences.</p>
    <pre>{ validator: function(doc) { return doc.age > 0 } }</pre>

    <h4>MinKey / MaxKey</h4>
    <p>Special internal types used for queries and index boundary markers. Not commonly stored in application documents.</p>

    <hr>
    <p><strong>Driver & index notes</strong></p>
    <ul>
        <li>Drivers map BSON types to native language types. Be explicit in your schema when precision matters (e.g., use NumberLong or Decimal128).</li>
        <li>Index size and ordering depend on the stored BSON representation — strings and binary fields can make indexes large quickly.</li>
        <li>Consistent typing across documents improves index selectivity and avoids surprising query behavior.</li>
    </ul>

    <p>If you'd like, I can add small examples for specific drivers (Node.js, Python) or add a summarized printable reference card for Unit 2.</p>

    <h3>Field Name Rules</h3>
    <div class="note">
        <ul>
            <li>Field names are case-sensitive</li>
            <li>Cannot contain <code>\0</code> (null character)</li>
            <li>Cannot start with <code>$</code> (reserved for operators)</li>
            <li>Cannot contain <code>.</code> (dot) (used for accessing nested fields)</li>
            <li><code>_id</code> is reserved for the primary key</li>
        </ul>
    </div>

    <h3>Document Example</h3>
    <pre>{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  username: "john_doe",
  profile: {
    firstName: "John",
    lastName: "Doe",
    age: 30,
    email: "john@example.com"
  },
  tags: ["developer", "mongodb", "javascript"],
  lastLogin: new Date("2025-10-31"),
  isActive: true,
  loginCount: NumberInt(42),
  metadata: null
}</pre>

    <div class="tip">
        <strong>Best Practices:</strong>
        <ul>
            <li>Use descriptive field names that reflect the data's purpose.</li>
            <li>Consider document growth when designing your schema.</li>
            <li>Use arrays for one-to-few relationships (embedded documents).</li>
            <li>Keep document size under 16MB to avoid splitting.</li>
        </ul>
    </div>

    <h2>Operations on Collections (CRUD and more)</h2>
    <p>Common operations you will use with collections.</p>

    <h4>Insert Documents</h4>
    <pre>// Insert one document
db.inventory.insertOne({ item: "pen", qty: 100 })

// Insert many documents
db.inventory.insertMany([
  { item: "notebook", qty: 200 },
  { item: "eraser", qty: 500 }
])</pre>

    <h4>Query / Find</h4>
    <pre>// Find all documents
 db.inventory.find()

// Find with filter and projection
 db.inventory.find({ qty: { $gt: 50 } }, { item: 1, qty: 1, _id: 0 }).pretty()

// Count results
 db.inventory.countDocuments({ qty: { $gt: 50 } })</pre>

    <h4>Update Documents</h4>
    <p>Use update operators to modify fields rather than replacing whole documents (unless you intend to replace).</p>
    <pre>// Update one document using $set
 db.inventory.updateOne({ item: "pen" }, { $set: { status: "active" } })

// Update many documents using $inc
 db.inventory.updateMany({ qty: { $lt: 30 } }, { $inc: { qty: 10 } })

// Replace a document entirely
 db.inventory.replaceOne({ _id: ObjectId("...") }, { item: "pen", qty: 120 })

// Upsert (update or insert)
 db.inventory.updateOne({ item: "marker" }, { $set: { qty: 50 } }, { upsert: true })</pre>

    <h4>Delete Documents</h4>
    <pre>// Delete one
db.inventory.deleteOne({ status: "inactive" })

// Delete many
db.inventory.deleteMany({ qty: 0 })</pre>

    <h4>Bulk Operations</h4>
    <p>For high-performance writes, use <code>bulkWrite()</code> to group operations:</p>
    <pre>db.collection.bulkWrite([
  { insertOne: { document: { a: 1 } } },
  { updateOne: { filter: { a: 1 }, update: { $set: { b: 1 } } } },
  { deleteOne: { filter: { a: 2 } } }
])</pre>
    <div class="footer">Return to <a href="index.html">Home</a> — or open Unit 1 / Unit 3 above.</div>
</div>
</body>
</html>
